# Задача 1
## Файл jsons_equality
Не очень ясно, нужен ли в качестве результата дифф или просто true/false. Сделал
второй вариант, т.к. так проще. Предположил, что json мы уже распаковали. В этой задаче и в остальных 
опустил тривиальные проверки на тип данных и т.п. 

# Задача 2
## Файл image_client
Позволил себе немного вольности - ввел ограничения на типы файлов и максимальный размер. 
Для разнообразия сделал загрузку асинхронной. Тесты не писал, нужны моки, это относительно
долго.

# Задача 3
## Файл performance_watcher

Общая идея - сделать декоратор, измеряющий время выполнения функции. В более реальном мире
можно можно для http запросов вместо декоратора использовать middleware, а декоратор уже на более
низком уровне. Если сервис асинхронный - то полезно в дебаг режиме установить loop.set_debug(True), 
это покажет корутины, выполняющиеся дольше 100 мсек.
В совсем реальном мире, конечно, стоит использовать что-то вроде prometheus.

# Задача 4

Идея следующая: сервис red пишет свои сообщения в RabbitMQ в таком формате:
```
    {
        'client_id': UUID,
        'red_level': <some level value>,
    }
```
сервис red_stats вычитывает их и складывает в MongoDB в коллекцию image_views в формате

```
    {
        'ClientID': UUID,
        'RedLevel': <some level value>,
        'ts': Unix ts
    }
```
Одновременно с вычитыванием сообщения сервис red_stats проверяет наличие подписки. 
Подписки хранятся в MongoDB, а так же в кэше сервиса. Кэш сбрасывается, например, по ttl.
Точнее метод инвалидации можно придумать только зная больше подробностей об эксплуатации сериса.
Если есть подписка, удовлетворяющая критерию RedLevel в сообщении, отсылается нотфикация клиенту.
Такая архитектура достаточно легко масштабируется горизонтально (досточно поднять
еще несколько инстансов сервиса red_stats). Также MongoDB лего шардируется.
Принципиальная схема архитекруры приведена в файле red_stats/scheme.pdf, диаграмма последовательности в файле 
red_stats/sequence_diagrame.png.
Сервис red_stats будет общаться с клиентами по REST API и предоставлять 3 метода:

GET /stat - возвращает статистку. Параметры - id клиента, значение количетсва красного и дипазон времени
POST /subscription - создает подписку, принимает id клиента и порог количества красного цвета
DELETE /subscription - создает подписку, принимает id клиента и порог количества красного цвета

Судя по всему, клиент может создать несколько подписок с разным порогом красного.

